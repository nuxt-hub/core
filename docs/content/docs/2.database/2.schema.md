---
title: Database Schema
description: Define and manage your database schema with Drizzle ORM in Nuxt, including tables, columns, relations, and type-safe models.
navigation.title: Schema
---

NuxtHub supports defining the database schema in multiple files and directories, allowing you to organize your schema files in a way that makes sense for your project and enabling Nuxt modules to extend the database schema.

### Schema files

Define your database schema in a single file or across multiple files. NuxtHub scans and auto-imports schema files following this glob pattern:
- `server/db/schema.ts`
- `server/db/schema.{dialect}.ts`
- `server/db/schema/*.ts`
- `server/db/schema/*.{dialect}.ts`

The merged schema is exported and can be imported in multiple ways:

```ts
// Import entire schema
import * as schema from '@nuxthub/db/schema'

// Also possible: Import schema object from main module
import { schema } from '@nuxthub/db'

// Legacy: Virtual module (backwards compatibility)
import * as schema from 'hub:db:schema'
```

::callout{icon="i-lucide-lightbulb"}
You can locate the generated schema file at `.nuxt/hub/db/schema.mjs`.
::

::note{to="https://orm.drizzle.team/docs/sql-schema-declaration" external}
Learn more about [Drizzle ORM schema](https://orm.drizzle.team/docs/sql-schema-declaration) on the Drizzle documentation.
::

## Relations

Drizzle ORM v1 introduces [relations v2](https://orm.drizzle.team/docs/relations-v2), a redesigned API for defining relationships between tables. In NuxtHub, use [`defineRelationsPart`](https://orm.drizzle.team/docs/relations-v2#relations-parts) to define relations in each schema file. NuxtHub merges all relation parts automatically at build time.

### Naming convention

Export each relation definition with a descriptive name that avoids conflicts with other exports across your schema files. The recommended pattern is `{tableName}Relations`:

```ts [server/db/schema/posts.ts]
// Table export
export const posts = pgTable('posts', { ... })

// Relations export â€” named "postsRelations" to avoid conflicts
export const postsRelations = defineRelationsPart({ posts, users }, r => ({
  posts: {
    author: r.one.users({
      from: r.posts.authorId,
      to: r.users.id
    })
  }
}))
```

### One-to-many

A one-to-many relation connects a single record in one table to multiple records in another. For example, a user who has many posts:

::tabs{sync="database-dialect"}
  :::tabs-item{label="PostgreSQL" icon="i-simple-icons-postgresql"}
    ::code-group
    ```ts [server/db/schema/users.ts]
    import { defineRelationsPart } from 'drizzle-orm'
    import { pgTable, text, serial, timestamp } from 'drizzle-orm/pg-core'
    import { posts } from '@nuxthub/db/schema'

    export const users = pgTable('users', {
      id: serial().primaryKey(),
      name: text().notNull(),
      email: text().notNull().unique(),
      createdAt: timestamp().notNull().defaultNow(),
    })

    export const usersRelations = defineRelationsPart({ users, posts }, r => ({
      users: {
        posts: r.many.posts()
      }
    }))
    ```

    ```ts [server/db/schema/posts.ts]
    import { users } from '@nuxthub/db/schema'
    import { defineRelationsPart } from 'drizzle-orm'
    import { pgTable, text, serial, integer, timestamp } from 'drizzle-orm/pg-core'

    export const posts = pgTable('posts', {
      id: serial().primaryKey(),
      title: text().notNull(),
      content: text().notNull(),
      authorId: integer('author_id').references(() => users.id),
      createdAt: timestamp().notNull().defaultNow(),
    })

    export const postsRelations = defineRelationsPart({ posts, users }, r => ({
      posts: {
        author: r.one.users({
          from: r.posts.authorId,
          to: r.users.id
        })
      }
    }))
    ```
    ::
  :::

  :::tabs-item{label="MySQL" icon="i-simple-icons-mysql"}
    ::code-group
    ```ts [server/db/schema/users.ts]
    import { defineRelationsPart } from 'drizzle-orm'
    import { mysqlTable, text, serial, timestamp } from 'drizzle-orm/mysql-core'
    import { posts } from '@nuxthub/db/schema'

    export const users = mysqlTable('users', {
      id: serial().primaryKey(),
      name: text().notNull(),
      email: text().notNull().unique(),
      createdAt: timestamp().notNull().defaultNow(),
    })

    export const usersRelations = defineRelationsPart({ users, posts }, r => ({
      users: {
        posts: r.many.posts()
      }
    }))
    ```

    ```ts [server/db/schema/posts.ts]
    import { users } from '@nuxthub/db/schema'
    import { defineRelationsPart } from 'drizzle-orm'
    import { mysqlTable, text, serial, int, timestamp } from 'drizzle-orm/mysql-core'

    export const posts = mysqlTable('posts', {
      id: serial().primaryKey(),
      title: text().notNull(),
      content: text().notNull(),
      authorId: int('author_id').references(() => users.id),
      createdAt: timestamp().notNull().defaultNow(),
    })

    export const postsRelations = defineRelationsPart({ posts, users }, r => ({
      posts: {
        author: r.one.users({
          from: r.posts.authorId,
          to: r.users.id
        })
      }
    }))
    ```
    ::
  :::

  :::tabs-item{label="SQLite" icon="i-simple-icons-sqlite"}
    ::code-group
    ```ts [server/db/schema/users.ts]
    import { defineRelationsPart, sql } from 'drizzle-orm'
    import { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core'
    import { posts } from '@nuxthub/db/schema'

    export const users = sqliteTable('users', {
      id: integer().primaryKey({ autoIncrement: true }),
      name: text().notNull(),
      email: text().notNull().unique(),
      createdAt: integer({ mode: 'timestamp' }).notNull().default(sql`(unixepoch())`),
    })

    export const usersRelations = defineRelationsPart({ users, posts }, r => ({
      users: {
        posts: r.many.posts()
      }
    }))
    ```

    ```ts [server/db/schema/posts.ts]
    import { users } from '@nuxthub/db/schema'
    import { defineRelationsPart, sql } from 'drizzle-orm'
    import { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core'

    export const posts = sqliteTable('posts', {
      id: integer().primaryKey({ autoIncrement: true }),
      title: text().notNull(),
      content: text().notNull(),
      authorId: integer('author_id').references(() => users.id),
      createdAt: integer({ mode: 'timestamp' }).notNull().default(sql`(unixepoch())`),
    })

    export const postsRelations = defineRelationsPart({ posts, users }, r => ({
      posts: {
        author: r.one.users({
          from: r.posts.authorId,
          to: r.users.id
        })
      }
    }))
    ```
    ::
  :::
::

### One-to-one

A one-to-one relation connects a single record to exactly one record in another table. For example, a user who has one profile:

```ts [server/db/schema/profiles.ts]
import { users } from '@nuxthub/db/schema'
import { defineRelationsPart } from 'drizzle-orm'
import { pgTable, text, serial, integer, jsonb } from 'drizzle-orm/pg-core'

export const profiles = pgTable('profiles', {
  id: serial().primaryKey(),
  userId: integer('user_id').references(() => users.id),
  bio: text(),
  metadata: jsonb(),
})

export const profilesRelations = defineRelationsPart({ profiles, users }, r => ({
  profiles: {
    user: r.one.users({
      from: r.profiles.userId,
      to: r.users.id
    })
  }
}))
```

### Many-to-many

A many-to-many relation uses a junction table to connect records. Use the `through` syntax to skip the junction table in query results:

```ts [server/db/schema/tags.ts]
import { posts } from '@nuxthub/db/schema'
import { defineRelationsPart } from 'drizzle-orm'
import { pgTable, text, serial, integer, primaryKey } from 'drizzle-orm/pg-core'

export const tags = pgTable('tags', {
  id: serial().primaryKey(),
  name: text().notNull().unique(),
})

export const postsToTags = pgTable('posts_to_tags', {
  postId: integer('post_id').notNull().references(() => posts.id),
  tagId: integer('tag_id').notNull().references(() => tags.id),
}, t => [primaryKey({ columns: [t.postId, t.tagId] })])

export const tagsRelations = defineRelationsPart({ tags, posts, postsToTags }, r => ({
  posts: {
    tags: r.many.tags({
      from: r.posts.id.through(r.postsToTags.postId),
      to: r.tags.id.through(r.postsToTags.tagId),
    })
  },
  tags: {
    posts: r.many.posts({
      from: r.tags.id.through(r.postsToTags.tagId),
      to: r.posts.id.through(r.postsToTags.postId),
    })
  }
}))
```

::note{to="https://orm.drizzle.team/docs/relations-v2" external}
Learn more about [Drizzle Relations v2](https://orm.drizzle.team/docs/relations-v2) on the Drizzle documentation.
::

### Nuxt layers

Database schema is scanned and automatically imported for each [Nuxt layer](https://nuxt.com/docs/getting-started/layers).

This means that you can also define schema in the `layers` directory:

```bash [Directory structure]
layers/cms/server/db/schema.ts
layers/products/server/db/schema/products.ts
```

### Nuxt modules

If you are a Nuxt module developer, you can also extend the database schema by using the `hub:db:schema:extend` hook:

```ts [modules/cms/index.ts]
import { defineNuxtModule, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const { resolvePath } = createResolver(import.meta.url)
    nuxt.hook('hub:db:schema:extend', async ({ dialect, paths }) => {
      // Add your module drizzle schema files for the given dialect
      // e.g. ./schema/pages.postgresql.ts if hub.db is 'postgresql'
      paths.push(await resolvePath(`./schema/pages.${dialect}`))
    })
  }
})
```

### Sharing types with Vue

Types inferred from your database schema are only available on the server-side by default. To share these types with your Vue application, you can use the [`shared/`](https://nuxt.com/docs/guide/directory-structure/shared) directory which is auto-imported across both server and client.

Create a types file in the `shared/types/` directory:

```ts [shared/types/db.ts]
import { users, posts } from '@nuxthub/db/schema'

// Select types (for reading data)
export type User = typeof users.$inferSelect
export type Post = typeof posts.$inferSelect

// Insert types (for creating data)
export type NewUser = typeof users.$inferInsert
export type NewPost = typeof posts.$inferInsert
```

These types are now auto-imported and available in your Vue components, composables, and API routes:

::code-group
```vue [pages/users.vue]
<script setup lang="ts">
const { data: users } = await useFetch<User[]>('/api/users')
</script>
```

```ts [server/api/users.post.ts]
import { db, schema } from '@nuxthub/db'

export default eventHandler(async (event) => {
  const body = await readBody<NewUser>(event)

  return await db.insert(schema.users).values(body).returning()
})
```
::

::tip
You can also create more specific types by using `Pick` and `Omit` TypeScript's built-in utility types.

```ts [shared/types/db.ts]
// User without password for public API responses
export type PublicUser = Omit<User, 'password'>

// Only the fields needed for user creation form
export type UserForm = Pick<NewUser, 'name' | 'email' | 'password'>
```
::


## Database seed

You can populate your database with initial data using [Nitro Tasks](https://nitro.build/guide/tasks):

::steps{level="3"}

### Enable Nitro tasks

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  nitro: {
    experimental: {
      tasks: true
    }
  }
})
```

### Create a seed task

```ts [server/tasks/seed.ts]
import { db, schema } from '@nuxthub/db'

export default defineTask({
  meta: {
    name: 'db:seed',
    description: 'Seed database with initial data'
  },
  async run() {
    console.log('Seeding database...')

    const users = [
      {
        name: 'John Doe',
        email: 'john@example.com',
        password: 'hashed_password',
        avatar: 'https://i.pravatar.cc/150?img=1',
        createdAt: new Date()
      },
      {
        name: 'Jane Doe',
        email: 'jane@example.com',
        password: 'hashed_password',
        avatar: 'https://i.pravatar.cc/150?img=2',
        createdAt: new Date()
      }
    ]

    await db.insert(schema.users).values(users)

    return { result: 'Database seeded successfully' }
  }
})
```

### Execute the task

Open the `Tasks` tab in Nuxt DevTools and click on the `db:seed` task.

::

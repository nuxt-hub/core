---
title: Blob Storage
navigation.title: Blob
description: Upload, store and serve images, videos, music, documents and other unstructured data in your Nuxt application.
---

## Getting Started

Enable blob storage in your project by setting `blob: true` in the NuxtHub config.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  hub: {
    blob: true
  }
})
```

### Automatic Configuration

NuxtHub automatically configures the blob storage driver based on your hosting provider when `blob: true` is set in the NuxtHub config.

::tabs{sync="provider"}
  :::tabs-item{label="Vercel Blob" icon="i-simple-icons-vercel"}

    When deploying to Vercel, it automatically configures [Vercel Blob Storage](https://vercel.com/docs/storage/vercel-blob).

    1. Install the `@vercel/blob` package

    :pm-install{name="@vercel/blob"}

    2. Assign a Vercel Blob Store to your project from the [Vercel dashboard](https://vercel.com/) -> Project -> Storage

    ::important
      Files stored in Vercel Blob are always public. Manually configure a different storage driver if storing sensitive files.
    ::

    3. When running locally, you can set the `BLOB_READ_WRITE_TOKEN` environment variable to enable the Vercel Blob driver:

    ```bash [.env]
    BLOB_READ_WRITE_TOKEN=your-token
    ```
  :::

  :::tabs-item{label="Cloudflare R2" icon="i-simple-icons-cloudflare"}

    When deploying to Cloudflare, it automatically configures [Cloudflare R2](https://developers.cloudflare.com/r2/).

    Add a `BLOB` binding to a [Cloudflare R2](https://developers.cloudflare.com/r2/) bucket in your `wrangler.jsonc` config.

    ```json [wrangler.jsonc]
    {
      "$schema": "node_modules/wrangler/config-schema.json",
      // ...
      "r2_buckets": [
        {
          "binding": "BLOB",
          "bucket_name": "<bucket_name>"
        }
      ]
    }
    ```

    Learn more about adding bindings on [Cloudflare's documentation](https://developers.cloudflare.com/r2/api/workers/workers-api-usage/).

    ::tip
      To use Cloudflare R2 without hosting on Cloudflare Workers, use the [Cloudflare R2 via S3 API](https://developers.cloudflare.com/r2/api/s3/api/).
    ::

  :::

  :::tabs-item{label="S3" icon="i-simple-icons-amazons3"}

    To configure [Amazon S3](https://aws.amazon.com/s3/) as a blob storage driver.

    1. Install the `aws4fetch` package
    
    :pm-install{name="aws4fetch"}

    2. Set the following environment variables:

    ```bash [.env]
    S3_ACCESS_KEY_ID=your-access-key-id
    S3_SECRET_ACCESS_KEY=your-secret-access-key
    S3_BUCKET=your-bucket-name
    S3_REGION=your-region
    S3_ENDPOINT=your-endpoint # (optional)
    ```
  :::

  :::tabs-item{label="Filesystem" icon="i-simple-icons-nodedotjs"}
    To customize the directory, you can set the `dir` option.

    ```ts [nuxt.config.ts]
    export default defineNuxtConfig({
      hub: {
        blob: {
          driver: 'fs',
          dir: '.data/my-blob-directory' // Defaults to `.data/blob`
        }
      }
    })
    ```

    ::important
      The local filesystem driver is not suitable for production environments.
    ::
  :::
::

::callout
By default, the local filesystem driver is used if no automatic configuration is found.
::

### Custom Driver

You can set a custom driver by providing a configuration object to `blob`.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  hub: {
    blob: {
      driver: 'fs',
      dir: '.data/blob'
    }
  },
  // or overwrite only in production
  $production: {
    hub: {
      blob: {
        driver: 'cloudflare-r2',
        binding: 'BLOB'
      }
    }
  }
})
```

::callout{to="https://unstorage.unjs.io/drivers"}
You can find the driver list on [unstorage documentation](https://unstorage.unjs.io/drivers) with their configuration.
::

## Usage

The `hub:blob` module provides access to the Blob storage through an [unstorage](https://unstorage.unjs.io) instance.

```ts
import { blob } from 'hub:blob'
```

::tip
`blob` is auto-imported on server-side, you can directly use it without importing it from `hub:blob`.
::

### `list()`

Returns a paginated list of blobs (metadata only).

```ts [server/api/files.get.ts]
import { blob } from 'hub:blob'

export default eventHandler(async () => {
  const { blobs } = await blob.list({ limit: 10 })

  return blobs
})
```

::note
When using the local filesystem driver, the `limit` option is ignored and all blobs are returned.
::

#### Params

::field-group
  ::field{name="options" type="Object"}
    The list options.
    ::collapsible
      ::field{name="limit" type="Number"}
        The maximum number of blobs to return per request. Defaults to `1000`.
      ::
      ::field{name="prefix" type="String"}
        Filters the results to only those that begin with the specified prefix.
      ::
      ::field{name="cursor" type="String"}
        The cursor to continue from a previous list operation.
      ::
      ::field{name="folded" type="Boolean"}
        If `true`, the list will be folded using `/` separator and list of folders will be returned.
      ::
    ::
  ::
::

#### Return

Returns [`BlobListResult`](#bloblistresult).

#### Return all blobs

To fetch all blobs, you can use a `while` loop to fetch the next page until the `cursor` is `null`.

```ts
import { blob } from 'hub:blob'

let blobs = []
let cursor = null

do {
  const res = await blob.list({ cursor })
  blobs.push(...res.blobs)
  cursor = res.cursor
} while (cursor)
```

### `serve()`

Returns a blob's data and sets `Content-Type`, `Content-Length` and `ETag` headers.

::code-group
```ts [server/routes/images/[...pathname\\].get.ts]
import { blob } from 'hub:blob'

export default eventHandler(async (event) => {
  const { pathname } = getRouterParams(event)

  return blob.serve(event, pathname)
})
```
```vue [pages/index.vue]
<template>
  <img src="/images/my-image.jpg">
</template>
```
::

::important
To prevent XSS attacks, make sure to control the Content type of the blob you serve.
::

You can also set a `Content-Security-Policy` header to add an additional layer of security:

```ts [server/api/images/[...pathname\\].get.ts]
import { blob } from 'hub:blob'

export default eventHandler(async (event) => {
  const { pathname } = getRouterParams(event)

  setHeader(event, 'Content-Security-Policy', 'default-src \'none\';')
  return blob.serve(event, pathname)
})
```

#### Params

::field-group
  ::field{name="event" type="H3Event"}
    Handler's event, needed to set headers.
  ::
  ::field{name="pathname" type="String"}
    The name of the blob to serve.
  ::
::

#### Return

Returns the blob's raw data and sets `Content-Type` and `Content-Length` headers.

### `head()`

Returns a blob's metadata.

```ts
const metadata = await blob.head(pathname)
```

#### Params

::field-group
  ::field{name="pathname" type="String"}
    The name of the blob to serve.
  ::
::

#### Return

Returns a [`BlobObject`](#blobobject).


### `get()`

Returns a blob body.

```ts
const file = await blob.get(pathname)
```

#### Params

::field-group
  ::field{name="pathname" type="String"}
    The name of the blob to serve.
  ::
::

#### Return

Returns a [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) or `null` if not found.

### `put()`

Uploads a blob to the storage.

```ts [server/api/files.post.ts]
import { blob } from 'hub:blob'

export default eventHandler(async (event) => {
  const form = await readFormData(event)
  const file = form.get('file') as File

  if (!file || !file.size) {
    throw createError({ statusCode: 400, message: 'No file provided' })
  }

  ensureBlob(file, {
    maxSize: '1MB',
    types: ['image']
  })

  return blob.put(file.name, file, {
    addRandomSuffix: false,
    prefix: 'images'
  })
})
```

See an example on the Vue side:

```vue [pages/upload.vue]
<script setup lang="ts">
async function uploadImage (e: Event) {
  const form = e.target as HTMLFormElement

  await $fetch('/api/files', {
    method: 'POST',
    body: new FormData(form)
  }).catch((err) => alert('Failed to upload image:\n'+ err.data?.message))

  form.reset()
}
</script>

<template>
  <form @submit.prevent="uploadImage">
    <label>Upload an image: <input type="file" name="image"></label>
    <button type="submit">
      Upload
    </button>
  </form>
</template>
```

#### Params

::field-group
  ::field{name="pathname" type="String"}
    The name of the blob to serve.
  ::
  ::field{name="body" type="String | ReadableStream<any> | ArrayBuffer | ArrayBufferView | Blob"}
    The blob's data.
  ::
  ::field{name="options" type="Object"}
    The put options. Any other provided field will be stored in the blob's metadata.
    ::collapsible
      ::field{name="contentType" type="String"}
        The content type of the blob. If not given, it will be inferred from the Blob or the file extension.
      ::
      ::field{name="contentLength" type="String"}
        The content length of the blob.
      ::
      ::field{name="addRandomSuffix" type="Boolean"}
        If `true`, a random suffix will be added to the blob's name. Defaults to `false`.
      ::
      ::field{name="prefix" type="string"}
        The prefix to use for the blob pathname.
      ::
      ::field{name="customMetadata" type="Record<string, string>"}
        An object with custom metadata to store with the blob. *(not supported in Vercel Blob driver at the moment)*
      ::
    ::
  ::
::

#### Return

Returns a [`BlobObject`](#blobobject).

### `del()`

Delete a blob with its pathname.

```ts [server/api/files/[...pathname\\].delete.ts]
import { blob } from 'hub:blob'

export default eventHandler(async (event) => {
  const { pathname } = getRouterParams(event)

  await blob.del(pathname)

  return sendNoContent(event)
})
```

You can also delete multiple blobs at once by providing an array of pathnames:

```ts
await blob.del(['images/1.jpg', 'images/2.jpg'])
```

::note
You can also use the `delete()` method as alias of `del()`.
::

#### Params

::field-group
  ::field{name="pathname" type="String"}
    The name of the blob to serve.
  ::
::

#### Return

Returns nothing.

### `handleUpload()`

This is an "all in one" function to validate a `Blob` by checking its size and type and upload it to the storage.

::note
This server util is made to be used with the [`useUpload()`](#useupload) Vue composable.
::

It can be used to handle file uploads in API routes.

::code-group
```ts [server/api/blob.put.ts]
import { blob } from 'hub:blob'

export default eventHandler(async (event) => {
  return blob.handleUpload(event, {
    formKey: 'files', // read file or files form the `formKey` field of request body (body should be a `FormData` object)
    multiple: true, // when `true`, the `formKey` field will be an array of `Blob` objects
    ensure: {
      types: ['image/jpeg', 'image/png'], // allowed types of the file
    },
    put: {
      addRandomSuffix: true
    }
  })
})
```
```vue [pages/upload.vue]
<script setup lang="ts">
const upload = useUpload('/api/blob', { method: 'PUT' })

async function onFileSelect(event: Event) {
  const uploadedFiles = await upload(event.target as HTMLInputElement)
  // file uploaded successfully
}
</script>

<template>
  <input type="file" name="file" @change="onFileSelect" multiple accept="image/jpeg, image/png" />
</template>
```
::

#### Params

::field-group
  ::field{name="formKey" type="string"}
    The form key to read the file from. Defaults to `'files'`.
  ::
  ::field{name="multiple" type="boolean"}
    When `true`, the `formKey` field will be an array of `Blob` objects.
  ::
  ::field{name="ensure" type="BlobEnsureOptions"}
    See [`ensureBlob()`](#ensureblob) options for more details.
  ::
  ::field{name="put" type="BlobPutOptions"}
    See [`put()`](#put) options for more details.
  ::
::

#### Return

Returns a [`BlobObject`](#blobobject) or an array of [`BlobObject`](#blobobject) if `multiple` is `true`.

Throws an error if `file` doesn't meet the requirements.

### `handleMultipartUpload()`

Handle the request to support multipart upload.

```ts [server/api/files/multipart/[action\\]/[...pathname\\].ts]
import { blob } from 'hub:blob'

export default eventHandler(async (event) => {
  return await blob.handleMultipartUpload(event)
})
```

::important
Make sure your route includes `[action]` and `[...pathname]` params.
::

On the client side, you can use the `useMultipartUpload()` composable to upload a file in parts.

```vue
<script setup lang="ts">
async function uploadFile(file: File) {
  const upload = useMultipartUpload('/api/files/multipart')

  const { progress, completed, abort } = upload(file)
}
</script>
```

::note{to="#usemultipartupload"}
See [`useMultipartUpload()`](#usemultipartupload) on usage details.
::


::important
Multipart uploads are only supported on Vercel Blob, Cloudflare R2, S3 and filesystem drivers.
::

#### Params

::field-group
  ::field{name="contentType" type="string"}
    The content type of the blob.
  ::
  ::field{name="contentLength" type="string"}
    The content length of the blob.
  ::
  ::field{name="addRandomSuffix" type="boolean"}
    If `true`, a random suffix will be added to the blob's name. Defaults to `false`.
  ::
::

### `createMultipartUpload()`

::note
We recommend using [`handleMultipartUpload()`](#handlemultipartupload) to handle the multipart upload requests.
:br
:br
If you want to handle multipart uploads manually using this utility, keep in mind that you cannot use this utility with Vercel Blob due to payload size limits on Vercel functions. Consider using [Vercel Blob Client SDK](https://vercel.com/docs/vercel-blob/client-upload).
::

Start a new multipart upload.

```ts [server/api/files/multipart/[...pathname\\].post.ts]
import { blob } from 'hub:blob'

export default eventHandler(async (event) => {
  const { pathname } = getRouterParams(event)

  const mpu = await blob.createMultipartUpload(pathname)

  return {
    uploadId: mpu.uploadId,
    pathname: mpu.pathname,
  }
})
```

#### Params

::field-group
  ::field{name="pathname" type="String"}
    The name of the blob to serve.
  ::
  ::field{name="options" type="Object"}
    The put options. Any other provided field will be stored in the blob's metadata.
    ::collapsible
      ::field{name="contentType" type="String"}
        The content type of the blob. If not given, it will be inferred from the Blob or the file extension.
      ::
      ::field{name="contentLength" type="String"}
        The content length of the blob.
      ::
      ::field{name="addRandomSuffix" type="Boolean"}
        If `true`, a random suffix will be added to the blob's name. Defaults to `true`.
      ::
    ::
  ::
::

#### Return

Returns a `BlobMultipartUpload`

### `resumeMultipartUpload()`

::note
We recommend using [`handleMultipartUpload()`](#handlemultipartupload) to handle the multipart upload requests.
::

Continue processing of unfinished multipart upload.

To upload a part of the multipart upload, you can use the `uploadPart()` method:

```ts [server/api/files/multipart/[...pathname\\].put.ts]
import { blob } from 'hub:blob'

export default eventHandler(async (event) => {
  const { pathname } = getRouterParams(event)
  const { uploadId, partNumber } = getQuery(event)

  const stream = getRequestWebStream(event)!
  const body = await streamToArrayBuffer(stream, contentLength)

  const mpu = blob.resumeMultipartUpload(pathname, uploadId)
  return await mpu.uploadPart(partNumber, body)
})
```

Complete the upload by calling `complete()` method:

```ts [server/api/files/multipart/complete.post.ts]
export default eventHandler(async (event) => {
  const { pathname, uploadId } = getQuery(event)
  const parts = await readBody(event)

  const mpu = blob.resumeMultipartUpload(pathname, uploadId)
  return await mpu.complete(parts)
})
```

If you want to cancel the upload, you need to call `abort()` method:

```ts [server/api/files/multipart/[...pathname\\].delete.ts]
export default eventHandler(async (event) => {
  const { pathname } = getRouterParams(event)
  const { uploadId } = getQuery(event)

  const mpu = blob.resumeMultipartUpload(pathname, uploadId)
  await mpu.abort()

  return sendNoContent(event)
})
```

A simple example of multipart upload in client with above routes:

```ts [utils/multipart-upload.ts]
async function uploadLargeFile(file: File) {
  const chunkSize = 10 * 1024 * 1024 // 10MB

  const count = Math.ceil(file.size / chunkSize)
  const { pathname, uploadId } = await $fetch(
    `/api/files/multipart/${file.name}`,
    { method: 'POST' },
  )

  const uploaded = []

  for (let i = 0; i < count; i++) {
    const start = i * chunkSize
    const end = Math.min(start + chunkSize, file.size)
    const partNumber = i + 1
    const chunk = file.slice(start, end)

    const part = await $fetch(
      `/api/files/multipart/${pathname}`,
      {
        method: 'PUT',
        query: { uploadId, partNumber },
        body: chunk,
      },
    )

    uploaded.push(part)
  }

  return await $fetch(
    '/api/files/multipart/complete',
    {
      method: 'POST',
      query: { pathname, uploadId },
      body: { parts: uploaded },
    },
  )
}
```

#### Params

::field-group
  ::field{name="pathname" type="String"}
    The name of the blob to serve.
  ::
  ::field{name="uploadId" type="String"}
    The upload ID of the multipart upload.
  ::
::

#### Return

Returns a `BlobMultipartUpload`


#### Params

::field-group
  ::field{name="event" type="H3Event" required}
    The event to handle.
  ::
::

## `ensureBlob()`

`ensureBlob()` is a handy util to validate a `Blob` by checking its size and type:

```ts
// Will throw an error if the file is not an image or is larger than 1MB
ensureBlob(file, { maxSize: '1MB', types: ['image']})
```

#### Params

::field-group
  ::field{name="file" type="Blob" required}
    The file to validate.
  ::
  ::field{name="options" type="Object" required}
    Note that at least `maxSize` or `types` should be provided.
    ::collapsible
      ::field{name="maxSize" type="BlobSize"}
        The maximum size of the file, should be: :br
        (`1` | `2` | `4` | `8` | `16` | `32` | `64` | `128` | `256` | `512` | `1024`) + (`B` | `KB` | `MB` | `GB`) :br
        e.g. `'512KB'`, `'1MB'`, `'2GB'`, etc.
      ::
      ::field{name="types" type="BlobType[]"}
        Allowed types of the file, e.g. `['image/jpeg']`.
      ::
    ::
  ::
::

#### Return

Returns nothing.

Throws an error if `file` doesn't meet the requirements.

## Vue Composables

::note
The following composables are meant to be used in the Vue side of your application (not the `server/` directory).
::

### `useUpload()`

`useUpload` is to handle file uploads in your Nuxt application.

```vue
<script setup lang="ts">
const upload = useUpload('/api/blob', { method: 'PUT' })

async function onFileSelect({ target }: Event) {
  const uploadedFiles = await upload(target as HTMLInputElement)

  // file uploaded successfully
}
</script>

<template>
  <input
    accept="image/jpeg, image/png"
    type="file"
    name="file"
    multiple
    @change="onFileSelect"
  >
</template>
```

#### Params

::field-group
  ::field{name="apiBase" type="string" required}
    The base URL of the upload API.
  ::
  ::field{name="options" type="Object" required}
    Optionally, you can pass Fetch options to the request. Read more about Fetch API [here](https://developer.mozilla.org/en-US/docs/Web/API/fetch#options).
    ::collapsible
      ::field{name="formKey" type="string"}
        The key to add the file/files to the request form. Defaults to `'files'`.
      ::
      ::field{name="multiple" type="boolean"}
        Whether to allow multiple files to be uploaded. Defaults to `true`.
      ::
    ::
  ::
::

#### Return

Return a `MultipartUpload` function that can be used to upload a file in parts.

```ts
const { completed, progress, abort } = upload(file)
const data = await completed
```

### `useMultipartUpload()`

Application composable that creates a multipart upload helper.

::important
When using the Vercel Blob driver, this utility will automatically use the [Vercel Blob Client SDK](https://vercel.com/docs/vercel-blob/client-upload) to upload the file.
::

```ts [utils/multipart-upload.ts]
export const mpu = useMultipartUpload('/api/files/multipart')
```

#### Params

::field-group
  ::field{name="baseURL" type="string"}
    The base URL of the multipart upload API handled by [`handleMultipartUpload()`](#handlemultipartupload).
  ::
  ::field{name="options"}
    The options for the multipart upload helper.
    ::collapsible
      ::field{name="partSize" type="number"}
        The size of each part of the file to be uploaded. Defaults to `10MB`.
      ::
      ::field{name="concurrent" type="number"}
        The maximum number of concurrent uploads. Defaults to `1`.
      ::
      ::field{name="maxRetry" type="number"}
        The maximum number of retry attempts for the whole upload. Defaults to `3`.
      ::
      ::field{name="prefix" type="string"}
        The prefix to use for the blob pathname.
      ::
      ::field{name="fetchOptions" type="Omit<FetchOptions, 'method' | 'baseURL' | 'body' | 'parseResponse' | 'responseType'>"}
        Override the ofetch options.
        The `query` and `headers` will be merged with the options provided by the uploader.
      ::
    ::
  ::
::

#### Return

Return a `MultipartUpload` function that can be used to upload a file in parts.

```ts
const { completed, progress, abort } = mpu(file)
const data = await completed
```

## Types

### `BlobObject`

```ts
interface BlobObject {
  pathname: string
  contentType: string | undefined
  size: number
  httpEtag: string
  uploadedAt: Date
  httpMetadata: Record<string, string>
  customMetadata: Record<string, string>
  url: string | undefined
}
```

### `BlobMultipartUpload`

```ts
export interface BlobMultipartUpload {
  pathname: string
  uploadId: string
  uploadPart(
    partNumber: number,
    value: string | ReadableStream<any> | ArrayBuffer | ArrayBufferView | Blob
  ): Promise<BlobUploadedPart>
  abort(): Promise<void>
  complete(uploadedParts: BlobUploadedPart[]): Promise<BlobObject>
}
```

### `BlobUploadedPart`

```ts
export interface BlobUploadedPart {
  partNumber: number;
  etag: string;
}
```

### `MultipartUploader`

```ts
export type MultipartUploader = (file: File) => {
  completed: Promise<SerializeObject<BlobObject> | undefined>
  progress: Readonly<Ref<number>>
  abort: () => Promise<void>
}
```

### `BlobListResult`

```ts
interface BlobListResult {
  blobs: BlobObject[]
  hasMore: boolean
  cursor?: string
  folders?: string[]
}
```

---
title: Using the Blob SDK
description: Learn how to use the hub:blob SDK to list, read, store, and delete files in your Blob Storage.
navigation.title: Blob SDK
---

The `hub:blob` module provides access to Blob Storage through a unified SDK that works across all storage providers (Cloudflare R2, S3, Vercel Blob, filesystem).

```ts
import { blob } from 'hub:blob'
```

::tip
`blob` is auto-imported on server-side, you can directly use it without importing it from `hub:blob`.
::

## List blobs

This example create an API route to list the first 10 blobs in the Blob storage.

```ts [server/api/files.get.ts]
export default eventHandler(async () => {
  const { blobs } = await blob.list({ limit: 10 })

  return blobs
})
```

### `list()`

Returns a paginated list of blobs (metadata only).

```ts
await blob.list(options)
```

::note
When using the local filesystem driver, the `limit` option is ignored and all blobs are returned.
::

#### Params

::field-group
  ::field{name="options" type="Object"}
    The list options.
    ::collapsible
      ::field{name="limit" type="Number"}
        The maximum number of blobs to return per request. Defaults to `1000`.
      ::
      ::field{name="prefix" type="String"}
        Filters the results to only those that begin with the specified prefix.
      ::
      ::field{name="cursor" type="String"}
        The cursor to continue from a previous list operation.
      ::
      ::field{name="folded" type="Boolean"}
        If `true`, the list will be folded using `/` separator and list of folders will be returned.
      ::
    ::
  ::
::

#### Return

Returns a json object with the following structure:

```ts-type
{
  blobs:  {
    pathname: string
    contentType: string | undefined
    size: number
    httpEtag: string | undefined
    uploadedAt: Date
    httpMetadata: Record<string, string>
    customMetadata: Record<string, string>
    url?: string
  }[]
  hasMore: boolean
  cursor?: string
  folders?: string[]
}
```

### List with prefix

Filter blobs by a prefix to organize files into directories:

```ts
// List all files in the "images/" directory
const { blobs } = await blob.list({ prefix: 'images/' })
```

### List with folders

Use `folded: true` to get a folder-like structure:

```ts
const { blobs, folders } = await blob.list({ folded: true })

// folders: ['images/', 'documents/', 'videos/']
```

### Pagination

Fetch all blobs using cursor-based pagination:

```ts
let allBlobs = []
let cursor = null

do {
  const result = await blob.list({ cursor })
  allBlobs.push(...result.blobs)
  cursor = result.cursor
} while (cursor)
```

## Serve a blob

This example create a server route on `/images/[...pathname]` to serve a blob by its pathname.

```ts [server/routes/images/[...pathname\\].get.ts]
export default eventHandler(async (event) => {
  const { pathname } = getRouterParams(event)

  return blob.serve(event, pathname)
})
```

To display the image in your application, you can use the `<img>` tag with the pathname of the blob.

```vue [pages/index.vue]
<template>
  <img src="/images/my-image.jpg">
</template>
```

::important
To prevent XSS attacks, make sure to control the Content type of the blob you serve.
::

You can also set a `Content-Security-Policy` header for additional security:

```ts [server/routes/images/[...pathname\\].get.ts]
export default eventHandler(async (event) => {
  const { pathname } = getRouterParams(event)

  setHeader(event, 'Content-Security-Policy', 'default-src \'none\';')
  return blob.serve(event, pathname)
})
```

### `serve()`

Returns a blob's data and sets `Content-Type`, `Content-Length`, and `ETag` headers.

```ts
await blob.serve(event, 'images/my-image.jpg')
```

#### Params

::field-group
  ::field{name="event" type="H3Event" required}
    Handler's event, needed to set headers.
  ::
  ::field{name="pathname" type="String" required}
    The pathname of the blob to serve.
  ::
::

#### Return

Returns the blob's raw data and sets `Content-Type`, `Content-Length`, and `ETag` headers.

## Get blob metadata

This example create an API route to get a blob's metadata by its pathname.

```ts [server/api/files/[...pathname\\].get.ts]
import { blob } from 'hub:blob'
import { eventHandler, getRouterParams } from 'h3'

export default eventHandler(async (event) => {
  const { pathname } = getRouterParams(event)

  return blob.head(pathname)
})
```

### `head()`

Returns a blob's metadata without fetching the content.

```ts
await blob.head('images/avatar.png')
// { pathname, contentType, size, uploadedAt, ... }
```

#### Params

::field-group
  ::field{name="pathname" type="String" required}
    The pathname of the blob.
  ::
::

#### Return

Returns a json object with the following structure:
```ts-type
{
  pathname: string
  contentType: string | undefined
  size: number
  httpEtag: string | undefined
  uploadedAt: Date
  httpMetadata: Record<string, string>
  customMetadata: Record<string, string>
  url?: string
}
```

## Get blob body

This example show a server code to get a blob's content by its pathname, and convert it to a text or buffer.

```ts
const file = await blob.get('documents/report.pdf')

if (file) {
  const text = await file.text()
  // or: const buffer = await file.arrayBuffer()
}
```

### `get()`

Returns a blob's content as a `Blob` object.

```ts
const file = await blob.get('documents/report.pdf')
```

#### Params

::field-group
  ::field{name="pathname" type="String" required}
    The pathname of the blob.
  ::
::

#### Return

Returns a [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) or `null` if not found.

## Upload a blob

This example create an API route to upload an image of 1MB maximum to the Blob storage.

```ts [server/api/files.post.ts]
import { ensureBlob, blob } from 'hub:blob'
import { eventHandler, readFormData, createError } from 'h3'

export default eventHandler(async (event) => {
  const form = await readFormData(event)
  const file = form.get('file') as File

  if (!file || !file.size) {
    throw createError({ statusCode: 400, message: 'No file provided' })
  }

  ensureBlob(file, {
    maxSize: '1MB',
    types: ['image'],
  })

  return blob.put(file.name, file, {
    addRandomSuffix: false,
    prefix: 'images',
  })
})
```

::tip{to="/docs/blob/upload"}
For a higher-level upload API with validation and client composables, see the **File Uploads** guide.
::

### `put()`

```ts
await blob.put('images/1.jpg', file)

await blob.put(file.name, file, {
  access: 'public',
  addRandomSuffix: true,
  prefix: 'images/',
  customMetadata: {
    userId: '123',
    category: 'reports',
  },
})
```

#### Params

::field-group
  ::field{name="pathname" type="String" required}
    The pathname for the blob.
  ::
  ::field{name="body" type="string | ReadableStream | ArrayBuffer | ArrayBufferView | Blob" required}
    The blob's data.
  ::
  ::field{name="options" type="Object"}
    The put options. Any other provided field will be stored in the blob's metadata.
    ::collapsible
      ::field{name="access" type="'public' | 'private'"}
        The access level of the blob. Note that only S3 driver supports this option.
      ::
      ::field{name="contentType" type="String"}
        The content type of the blob. If not given, it will be inferred from the Blob or file extension.
      ::
      ::field{name="contentLength" type="String"}
        The content length of the blob.
      ::
      ::field{name="addRandomSuffix" type="Boolean"}
        If `true`, a random suffix will be added to the blob's pathname. Defaults to `false`.
      ::
      ::field{name="prefix" type="string"}
        The prefix to use for the blob pathname.
      ::
      ::field{name="customMetadata" type="Record<string, string>"}
        Custom metadata to store with the blob. *(not supported in Vercel Blob driver)*
      ::
    ::
  ::
::

#### Return

Returns a json object with the following structure:

```ts-type
{
  pathname: string
  contentType: string | undefined
  size: number
  httpEtag: string | undefined
  uploadedAt: Date
  httpMetadata: Record<string, string>
  customMetadata: Record<string, string>
  url?: string
}
```

#### Upload Examples

**Upload from a URL:**

```ts
const response = await fetch('https://example.com/image.png')
const imageBlob = await response.blob()

await blob.put('downloads/image.png', imageBlob)
```

**Upload with custom metadata:**

```ts
await blob.put('documents/report.pdf', pdfFile, {
  customMetadata: {
    userId: '123',
    category: 'reports',
  },
})
```

**Upload to a specific folder:**

```ts
await blob.put('avatar.png', file, {
  prefix: `users/${userId}`,
})
// Stored as: users/123/avatar.png
```

## Deleting blobs

To delete a file, you can use the `blob.del()` method. 

This example create an API route to delete a blob by its pathname.

```ts [server/api/files/[...pathname\\].delete.ts]
import { blob } from 'hub:blob'
import { eventHandler, getRouterParams, sendNoContent } from 'h3'

export default eventHandler(async (event) => {
  const { pathname } = getRouterParams(event)

  await blob.del(pathname)

  return sendNoContent(event)
})
```

### `del()`

The `del()` method deletes one or multiple blob objects from the Blob storage.

You can also delete multiple blobs at once:

```ts
await blob.del('images/1.jpg')
await blob.del(['images/1.jpg', 'images/2.jpg', 'images/3.jpg'])
```

::note
You can also use `delete()` as an alias for `del()`.
::

#### Params

::field-group
  ::field{name="pathname" type="String | String[]" required}
    The pathname(s) of the blob(s) to delete.
  ::
::

#### Return

Returns nothing.

## Validation

### `ensureBlob()`

A server-side utility to validate a file by checking its size and type before uploading.

```ts
import { ensureBlob } from 'hub:blob'

// Will throw an error if the file is not an image or is larger than 1MB
ensureBlob(file, { maxSize: '1MB', types: ['image'] })
```

::tip
This utility is automatically used by [`handleUpload()`](#handleupload) when you provide the `ensure` option.
::

#### Params

::field-group
  ::field{name="file" type="Blob" required}
    The file to validate.
  ::
  ::field{name="options" type="Object" required}
    Note that at least `maxSize` or `types` should be provided.
    ::collapsible
      ::field{name="maxSize" type="BlobSize"}
        The maximum size of the file, should be: :br
        (`1` | `2` | `4` | `8` | `16` | `32` | `64` | `128` | `256` | `512` | `1024`) + (`B` | `KB` | `MB` | `GB`) :br
        e.g. `'512KB'`, `'1MB'`, `'2GB'`, etc.
      ::
      ::field{name="types" type="BlobType[]"}
        Allowed types of the file, e.g. `['image/jpeg']`, `['image']`, `['video']`, `['pdf']`, etc.
      ::
    ::
  ::
::

#### Return

Returns nothing. Throws an error if the file doesn't meet the requirements.

## Image Optimization

[`@nuxt/image`](https://image.nuxt.com) provides automatic image optimization. You can combine it with blob storage to serve optimized images from your storage.

::steps{level="3"}

### Install @nuxt/image

:pm-install{name="@nuxt/image"}

### Create a route to serve blob images

Create a catch-all route that serves images from blob storage:

```ts [server/routes/images/[...pathname].get.ts]
export default defineEventHandler(async (event) => {
  const pathname = getRouterParam(event, 'pathname')
  return blob.serve(event, pathname!)
})
```

### Configure the image provider

Configure `@nuxt/image` to use the appropriate provider for your hosting platform:

::tabs{sync="provider"}
  :::tabs-item{label="Cloudflare" icon="i-simple-icons-cloudflare"}
  ```ts [nuxt.config.ts]
  export default defineNuxtConfig({
    modules: ['@nuxthub/core', '@nuxt/image'],
    image: {
      provider: 'cloudflare',
      cloudflare: { baseURL: '/images' }
    }
  })
  ```
  ::callout{to="https://image.nuxt.com/providers/cloudflare"}
  See Cloudflare provider docs for requirements and options.
  ::
  :::
  :::tabs-item{label="Vercel" icon="i-simple-icons-vercel"}
  ```ts [nuxt.config.ts]
  export default defineNuxtConfig({
    modules: ['@nuxthub/core', '@nuxt/image'],
    image: {
      provider: 'vercel'
    }
  })
  ```
  ::callout{to="https://image.nuxt.com/providers/vercel"}
  See Vercel provider docs for requirements and options.
  ::
  :::
::

### Use NuxtImg or NuxtPicture

Use the components to display optimized images from blob storage:

```vue [pages/gallery.vue]
<template>
  <NuxtImg src="/images/photo.jpg" width="300" quality="80" />
</template>
```

The `src` path combines your route prefix (`/images`) with the blob pathname (`photo.jpg`).

::

